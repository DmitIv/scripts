from typing import NewType, Any, Tuple, List, TypedDict
from brownie.typing import TransactionReceiptType, AccountsType

from brownie.network.contract import InterfaceContainer as BrownieInterfaceContainer, Contract
from brownie.network.contract import ContractTx, ContractCall

uint8 = NewType('uint8', int)
uint16 = NewType('uint16', int)
uint32 = NewType('uint32', int)
uint64 = NewType('uint64', int)
uint240 = NewType('uint240', int)
uint256 = NewType('uint256', int)
address = NewType('address', str)
bytes32 = NewType('bytes32', str)
string = NewType('string', str)
struct = NewType('struct', Any)


class ACL(Contract):
    def hasInitialized(self, tx_params) -> bool: ...

    def getPermissionParamsLength(self, _entity: address, _app: address, _role: bytes32, tx_params) -> uint256: ...

    def evalParams(self, _paramsHash: bytes32, _who: address, _where: address, _what: bytes32, _how: List[uint256],
                   tx_params) -> bool: ...

    def NO_PERMISSION(self, tx_params) -> bytes32: ...

    def getEVMScriptExecutor(self, _script: bytes, tx_params) -> address: ...

    def getRecoveryVault(self, tx_params) -> address: ...

    def CREATE_PERMISSIONS_ROLE(self, tx_params) -> bytes32: ...

    def hasPermission(self, _who: address, _where: address, _what: bytes32, tx_params) -> bool: ...

    def allowRecoverability(self, token: address, tx_params) -> bool: ...

    def appId(self, tx_params) -> bytes32: ...

    def getInitializationBlock(self, tx_params) -> uint256: ...

    def getPermissionParam(self, _entity: address, _app: address, _role: bytes32, _index: uint256, tx_params) -> Tuple[
        uint8, uint8, uint240]: ...

    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], tx_params) -> bool: ...

    def getEVMScriptRegistry(self, tx_params) -> address: ...

    def ANY_ENTITY(self, tx_params) -> address: ...

    def getPermissionManager(self, _app: address, _role: bytes32, tx_params) -> address: ...

    def EMPTY_PARAM_HASH(self, tx_params) -> bytes32: ...

    def kernel(self, tx_params) -> address: ...

    def isPetrified(self, tx_params) -> bool: ...

    def BURN_ENTITY(self, tx_params) -> address: ...

    def hasPermission(self, _who: address, _where: address, _what: bytes32, _how: List[uint256], tx_params) -> bool: ...

    def hasPermission(self, _who: address, _where: address, _what: bytes32, _how: bytes, tx_params) -> bool: ...

    def createBurnedPermission(self, _app: address, _role: bytes32, tx_params) -> None: ...

    def burnPermissionManager(self, _app: address, _role: bytes32, tx_params) -> None: ...

    def grantPermission(self, _entity: address, _app: address, _role: bytes32, tx_params) -> None: ...

    def grantPermissionP(self, _entity: address, _app: address, _role: bytes32, _params: List[uint256],
                         tx_params) -> None: ...

    def revokePermission(self, _entity: address, _app: address, _role: bytes32, tx_params) -> None: ...

    def transferToVault(self, _token: address, tx_params) -> None: ...

    def removePermissionManager(self, _app: address, _role: bytes32, tx_params) -> None: ...

    def setPermissionManager(self, _newManager: address, _app: address, _role: bytes32, tx_params) -> None: ...

    def createPermission(self, _entity: address, _app: address, _role: bytes32, _manager: address,
                         tx_params) -> None: ...

    def initialize(self, _permissionsCreator: address, tx_params) -> None: ...

    hasInitialized: ContractCall
    getPermissionParamsLength: ContractCall
    evalParams: ContractCall
    NO_PERMISSION: ContractCall
    getEVMScriptExecutor: ContractCall
    getRecoveryVault: ContractCall
    CREATE_PERMISSIONS_ROLE: ContractCall
    hasPermission: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getInitializationBlock: ContractCall
    getPermissionParam: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    ANY_ENTITY: ContractCall
    getPermissionManager: ContractCall
    EMPTY_PARAM_HASH: ContractCall
    kernel: ContractCall
    isPetrified: ContractCall
    BURN_ENTITY: ContractCall
    hasPermission: ContractCall
    hasPermission: ContractCall
    createBurnedPermission: ContractTx
    burnPermissionManager: ContractTx
    grantPermission: ContractTx
    grantPermissionP: ContractTx
    revokePermission: ContractTx
    transferToVault: ContractTx
    removePermissionManager: ContractTx
    setPermissionManager: ContractTx
    createPermission: ContractTx
    initialize: ContractTx


class CurveRewardsManager(Contract):
    def is_rewards_period_finished(self, tx_params) -> bool: ...

    def owner(self, tx_params) -> address: ...

    def rewards_contract(self, tx_params) -> address: ...

    def transfer_ownership(self, _to: address, tx_params) -> None: ...

    def set_rewards_contract(self, _rewards_contract: address, tx_params) -> None: ...

    def start_next_rewards_period(self, tx_params) -> None: ...

    def recover_erc20(self, _token: address, tx_params) -> None: ...

    def recover_erc20(self, _token: address, _recipient: address, tx_params) -> None: ...

    is_rewards_period_finished: ContractCall
    owner: ContractCall
    rewards_contract: ContractCall
    transfer_ownership: ContractTx
    set_rewards_contract: ContractTx
    start_next_rewards_period: ContractTx
    recover_erc20: ContractTx
    recover_erc20: ContractTx


class ERC20(Contract):
    def allowance(self, _owner: address, _spender: address, tx_params) -> uint256: ...

    def balanceOf(self, _owner: address, tx_params) -> uint256: ...

    def decimals(self, tx_params) -> uint256: ...

    def name(self, tx_params) -> string: ...

    def symbol(self, tx_params) -> string: ...

    def totalSupply(self, tx_params) -> uint256: ...

    def approve(self, _spender: address, _value: uint256, tx_params) -> bool: ...

    def transfer(self, _to: address, _value: uint256, tx_params) -> bool: ...

    def transferFrom(self, _from: address, _to: address, _value: uint256, tx_params) -> bool: ...

    allowance: ContractCall
    balanceOf: ContractCall
    decimals: ContractCall
    name: ContractCall
    symbol: ContractCall
    totalSupply: ContractCall
    approve: ContractTx
    transfer: ContractTx
    transferFrom: ContractTx


class Finance(Contract):
    def hasInitialized(self, tx_params) -> bool: ...

    def CREATE_PAYMENTS_ROLE(self, tx_params) -> bytes32: ...

    def getBudget(self, _token: address, tx_params) -> Tuple[uint256, bool]: ...

    def getEVMScriptExecutor(self, _script: bytes, tx_params) -> address: ...

    def getPayment(self, _paymentId: uint256, tx_params) -> Tuple[
        address, address, uint256, uint64, uint64, uint64, bool, uint64, address]: ...

    def getRecoveryVault(self, tx_params) -> address: ...

    def getTransaction(self, _transactionId: uint256, tx_params) -> Tuple[
        uint64, uint256, uint256, uint64, address, address, bool, uint64]: ...

    def CHANGE_PERIOD_ROLE(self, tx_params) -> bytes32: ...

    def CHANGE_BUDGETS_ROLE(self, tx_params) -> bytes32: ...

    def getPeriod(self, _periodId: uint64, tx_params) -> Tuple[bool, uint64, uint64, uint256, uint256]: ...

    def periodsLength(self, tx_params) -> uint64: ...

    def allowRecoverability(self, _arg0: address, tx_params) -> bool: ...

    def appId(self, tx_params) -> bytes32: ...

    def getInitializationBlock(self, tx_params) -> uint256: ...

    def EXECUTE_PAYMENTS_ROLE(self, tx_params) -> bytes32: ...

    def currentPeriodId(self, tx_params) -> uint64: ...

    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], tx_params) -> bool: ...

    def getEVMScriptRegistry(self, tx_params) -> address: ...

    def getPeriodDuration(self, tx_params) -> uint64: ...

    def nextPaymentTime(self, _paymentId: uint256, tx_params) -> uint64: ...

    def getPeriodTokenStatement(self, _periodId: uint64, _token: address, tx_params) -> Tuple[uint256, uint256]: ...

    def kernel(self, tx_params) -> address: ...

    def paymentsNextIndex(self, tx_params) -> uint256: ...

    def isPetrified(self, tx_params) -> bool: ...

    def canMakePayment(self, _token: address, _amount: uint256, tx_params) -> bool: ...

    def MANAGE_PAYMENTS_ROLE(self, tx_params) -> bytes32: ...

    def transactionsNextIndex(self, tx_params) -> uint256: ...

    def getRemainingBudget(self, _token: address, tx_params) -> uint256: ...

    def vault(self, tx_params) -> address: ...

    def newScheduledPayment(self, _token: address, _receiver: address, _amount: uint256, _initialPaymentTime: uint64,
                            _interval: uint64, _maxExecutions: uint64, _reference: string, tx_params) -> uint256: ...

    def executePayment(self, _paymentId: uint256, tx_params) -> None: ...

    def initialize(self, _vault: address, _periodDuration: uint64, tx_params) -> None: ...

    def removeBudget(self, _token: address, tx_params) -> None: ...

    def setPaymentStatus(self, _paymentId: uint256, _active: bool, tx_params) -> None: ...

    def receiverExecutePayment(self, _paymentId: uint256, tx_params) -> None: ...

    def setPeriodDuration(self, _periodDuration: uint64, tx_params) -> None: ...

    def setBudget(self, _token: address, _amount: uint256, tx_params) -> None: ...

    def recoverToVault(self, _token: address, tx_params) -> None: ...

    def transferToVault(self, _token: address, tx_params) -> None: ...

    def tryTransitionAccountingPeriod(self, _maxTransitions: uint64, tx_params) -> bool: ...

    def deposit(self, _token: address, _amount: uint256, _reference: string, tx_params) -> None: ...

    def newImmediatePayment(self, _token: address, _receiver: address, _amount: uint256, _reference: string,
                            tx_params) -> None: ...

    hasInitialized: ContractCall
    CREATE_PAYMENTS_ROLE: ContractCall
    getBudget: ContractCall
    getEVMScriptExecutor: ContractCall
    getPayment: ContractCall
    getRecoveryVault: ContractCall
    getTransaction: ContractCall
    CHANGE_PERIOD_ROLE: ContractCall
    CHANGE_BUDGETS_ROLE: ContractCall
    getPeriod: ContractCall
    periodsLength: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getInitializationBlock: ContractCall
    EXECUTE_PAYMENTS_ROLE: ContractCall
    currentPeriodId: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    getPeriodDuration: ContractCall
    nextPaymentTime: ContractCall
    getPeriodTokenStatement: ContractCall
    kernel: ContractCall
    paymentsNextIndex: ContractCall
    isPetrified: ContractCall
    canMakePayment: ContractCall
    MANAGE_PAYMENTS_ROLE: ContractCall
    transactionsNextIndex: ContractCall
    getRemainingBudget: ContractCall
    vault: ContractCall
    newScheduledPayment: ContractTx
    executePayment: ContractTx
    initialize: ContractTx
    removeBudget: ContractTx
    setPaymentStatus: ContractTx
    receiverExecutePayment: ContractTx
    setPeriodDuration: ContractTx
    setBudget: ContractTx
    recoverToVault: ContractTx
    transferToVault: ContractTx
    tryTransitionAccountingPeriod: ContractTx
    deposit: ContractTx
    newImmediatePayment: ContractTx


class Lido(Contract):
    def name(self, tx_params) -> string: ...

    def hasInitialized(self, tx_params) -> bool: ...

    def getInsuranceFund(self, tx_params) -> address: ...

    def totalSupply(self, tx_params) -> uint256: ...

    def getSharesByPooledEth(self, _ethAmount: uint256, tx_params) -> uint256: ...

    def getOperators(self, tx_params) -> address: ...

    def getEVMScriptExecutor(self, _script: bytes, tx_params) -> address: ...

    def decimals(self, tx_params) -> uint8: ...

    def getRecoveryVault(self, tx_params) -> address: ...

    def DEPOSIT_SIZE(self, tx_params) -> uint256: ...

    def getTotalPooledEther(self, tx_params) -> uint256: ...

    def PAUSE_ROLE(self, tx_params) -> bytes32: ...

    def getTreasury(self, tx_params) -> address: ...

    def SET_ORACLE(self, tx_params) -> bytes32: ...

    def isStopped(self, tx_params) -> bool: ...

    def MANAGE_WITHDRAWAL_KEY(self, tx_params) -> bytes32: ...

    def getBufferedEther(self, tx_params) -> uint256: ...

    def SIGNATURE_LENGTH(self, tx_params) -> uint256: ...

    def getWithdrawalCredentials(self, tx_params) -> bytes32: ...

    def balanceOf(self, _account: address, tx_params) -> uint256: ...

    def getFeeDistribution(self, tx_params) -> Tuple[uint16, uint16, uint16]: ...

    def getPooledEthByShares(self, _sharesAmount: uint256, tx_params) -> uint256: ...

    def allowRecoverability(self, token: address, tx_params) -> bool: ...

    def appId(self, tx_params) -> bytes32: ...

    def getOracle(self, tx_params) -> address: ...

    def getInitializationBlock(self, tx_params) -> uint256: ...

    def symbol(self, tx_params) -> string: ...

    def MANAGE_FEE(self, tx_params) -> bytes32: ...

    def SET_TREASURY(self, tx_params) -> bytes32: ...

    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], tx_params) -> bool: ...

    def WITHDRAWAL_CREDENTIALS_LENGTH(self, tx_params) -> uint256: ...

    def getEVMScriptRegistry(self, tx_params) -> address: ...

    def PUBKEY_LENGTH(self, tx_params) -> uint256: ...

    def getDepositContract(self, tx_params) -> address: ...

    def getBeaconStat(self, tx_params) -> Tuple[uint256, uint256, uint256]: ...

    def BURN_ROLE(self, tx_params) -> bytes32: ...

    def getFee(self, tx_params) -> uint16: ...

    def SET_INSURANCE_FUND(self, tx_params) -> bytes32: ...

    def kernel(self, tx_params) -> address: ...

    def getTotalShares(self, tx_params) -> uint256: ...

    def allowance(self, _owner: address, _spender: address, tx_params) -> uint256: ...

    def isPetrified(self, tx_params) -> bool: ...

    def sharesOf(self, _account: address, tx_params) -> uint256: ...

    def resume(self, tx_params) -> None: ...

    def stop(self, tx_params) -> None: ...

    def approve(self, _spender: address, _amount: uint256, tx_params) -> bool: ...

    def initialize(self, depositContract: address, _oracle: address, _operators: address, _treasury: address,
                   _insuranceFund: address, tx_params) -> None: ...

    def transferFrom(self, _sender: address, _recipient: address, _amount: uint256, tx_params) -> bool: ...

    def increaseAllowance(self, _spender: address, _addedValue: uint256, tx_params) -> bool: ...

    def setOracle(self, _oracle: address, tx_params) -> None: ...

    def setFeeDistribution(self, _treasuryFeeBasisPoints: uint16, _insuranceFeeBasisPoints: uint16,
                           _operatorsFeeBasisPoints: uint16, tx_params) -> None: ...

    def setFee(self, _feeBasisPoints: uint16, tx_params) -> None: ...

    def depositBufferedEther(self, _maxDeposits: uint256, tx_params) -> None: ...

    def transferToVault(self, _token: address, tx_params) -> None: ...

    def submit(self, _referral: address, tx_params) -> uint256: ...

    def decreaseAllowance(self, _spender: address, _subtractedValue: uint256, tx_params) -> bool: ...

    def withdraw(self, _amount: uint256, _pubkeyHash: bytes32, tx_params) -> None: ...

    def transfer(self, _recipient: address, _amount: uint256, tx_params) -> bool: ...

    def setInsuranceFund(self, _insuranceFund: address, tx_params) -> None: ...

    def setWithdrawalCredentials(self, _withdrawalCredentials: bytes32, tx_params) -> None: ...

    def depositBufferedEther(self, tx_params) -> None: ...

    def burnShares(self, _account: address, _sharesAmount: uint256, tx_params) -> uint256: ...

    def setTreasury(self, _treasury: address, tx_params) -> None: ...

    def pushBeacon(self, _beaconValidators: uint256, _beaconBalance: uint256, tx_params) -> None: ...

    name: ContractCall
    hasInitialized: ContractCall
    getInsuranceFund: ContractCall
    totalSupply: ContractCall
    getSharesByPooledEth: ContractCall
    getOperators: ContractCall
    getEVMScriptExecutor: ContractCall
    decimals: ContractCall
    getRecoveryVault: ContractCall
    DEPOSIT_SIZE: ContractCall
    getTotalPooledEther: ContractCall
    PAUSE_ROLE: ContractCall
    getTreasury: ContractCall
    SET_ORACLE: ContractCall
    isStopped: ContractCall
    MANAGE_WITHDRAWAL_KEY: ContractCall
    getBufferedEther: ContractCall
    SIGNATURE_LENGTH: ContractCall
    getWithdrawalCredentials: ContractCall
    balanceOf: ContractCall
    getFeeDistribution: ContractCall
    getPooledEthByShares: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getOracle: ContractCall
    getInitializationBlock: ContractCall
    symbol: ContractCall
    MANAGE_FEE: ContractCall
    SET_TREASURY: ContractCall
    canPerform: ContractCall
    WITHDRAWAL_CREDENTIALS_LENGTH: ContractCall
    getEVMScriptRegistry: ContractCall
    PUBKEY_LENGTH: ContractCall
    getDepositContract: ContractCall
    getBeaconStat: ContractCall
    BURN_ROLE: ContractCall
    getFee: ContractCall
    SET_INSURANCE_FUND: ContractCall
    kernel: ContractCall
    getTotalShares: ContractCall
    allowance: ContractCall
    isPetrified: ContractCall
    sharesOf: ContractCall
    resume: ContractTx
    stop: ContractTx
    approve: ContractTx
    initialize: ContractTx
    transferFrom: ContractTx
    increaseAllowance: ContractTx
    setOracle: ContractTx
    setFeeDistribution: ContractTx
    setFee: ContractTx
    depositBufferedEther: ContractTx
    transferToVault: ContractTx
    submit: ContractTx
    decreaseAllowance: ContractTx
    withdraw: ContractTx
    transfer: ContractTx
    setInsuranceFund: ContractTx
    setWithdrawalCredentials: ContractTx
    depositBufferedEther: ContractTx
    burnShares: ContractTx
    setTreasury: ContractTx
    pushBeacon: ContractTx


class Multicall2(Contract):
    def aggregate(self, calls: List[struct], tx_params) -> Tuple[uint256, List[bytes]]: ...

    def blockAndAggregate(self, calls: List[struct], tx_params) -> Tuple[uint256, bytes32, List[struct]]: ...

    def getBlockHash(self, blockNumber: uint256, tx_params) -> bytes32: ...

    def getBlockNumber(self, tx_params) -> uint256: ...

    def getCurrentBlockCoinbase(self, tx_params) -> address: ...

    def getCurrentBlockDifficulty(self, tx_params) -> uint256: ...

    def getCurrentBlockGasLimit(self, tx_params) -> uint256: ...

    def getCurrentBlockTimestamp(self, tx_params) -> uint256: ...

    def getEthBalance(self, addr: address, tx_params) -> uint256: ...

    def getLastBlockHash(self, tx_params) -> bytes32: ...

    def tryAggregate(self, requireSuccess: bool, calls: List[struct], tx_params) -> List[struct]: ...

    def tryBlockAndAggregate(self, requireSuccess: bool, calls: List[struct], tx_params) -> Tuple[
        uint256, bytes32, List[struct]]: ...

    aggregate: ContractCall
    blockAndAggregate: ContractCall
    getBlockHash: ContractCall
    getBlockNumber: ContractCall
    getCurrentBlockCoinbase: ContractCall
    getCurrentBlockDifficulty: ContractCall
    getCurrentBlockGasLimit: ContractCall
    getCurrentBlockTimestamp: ContractCall
    getEthBalance: ContractCall
    getLastBlockHash: ContractCall
    tryAggregate: ContractCall
    tryBlockAndAggregate: ContractCall


class NodeOperatorsRegistry(Contract):
    def hasInitialized(self, tx_params) -> bool: ...

    def getEVMScriptExecutor(self, _script: bytes, tx_params) -> address: ...

    def getRecoveryVault(self, tx_params) -> address: ...

    def SIGNATURE_LENGTH(self, tx_params) -> uint256: ...

    def SET_NODE_OPERATOR_ADDRESS_ROLE(self, tx_params) -> bytes32: ...

    def getRewardsDistribution(self, _totalRewardShares: uint256, tx_params) -> Tuple[List[address], List[uint256]]: ...

    def SET_NODE_OPERATOR_NAME_ROLE(self, tx_params) -> bytes32: ...

    def ADD_NODE_OPERATOR_ROLE(self, tx_params) -> bytes32: ...

    def allowRecoverability(self, token: address, tx_params) -> bool: ...

    def appId(self, tx_params) -> bytes32: ...

    def getActiveNodeOperatorsCount(self, tx_params) -> uint256: ...

    def getInitializationBlock(self, tx_params) -> uint256: ...

    def getUnusedSigningKeyCount(self, _operator_id: uint256, tx_params) -> uint256: ...

    def getNodeOperator(self, _id: uint256, _fullInfo: bool, tx_params) -> Tuple[
        bool, string, address, uint64, uint64, uint64, uint64]: ...

    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], tx_params) -> bool: ...

    def getEVMScriptRegistry(self, tx_params) -> address: ...

    def PUBKEY_LENGTH(self, tx_params) -> uint256: ...

    def getNodeOperatorsCount(self, tx_params) -> uint256: ...

    def getSigningKey(self, _operator_id: uint256, _index: uint256, tx_params) -> Tuple[bytes, bytes, bool]: ...

    def REPORT_STOPPED_VALIDATORS_ROLE(self, tx_params) -> bytes32: ...

    def kernel(self, tx_params) -> address: ...

    def SET_NODE_OPERATOR_ACTIVE_ROLE(self, tx_params) -> bytes32: ...

    def SET_NODE_OPERATOR_LIMIT_ROLE(self, tx_params) -> bytes32: ...

    def getTotalSigningKeyCount(self, _operator_id: uint256, tx_params) -> uint256: ...

    def isPetrified(self, tx_params) -> bool: ...

    def MANAGE_SIGNING_KEYS(self, tx_params) -> bytes32: ...

    def addNodeOperator(self, _name: string, _rewardAddress: address, _stakingLimit: uint64, tx_params) -> uint256: ...

    def addSigningKeys(self, _operator_id: uint256, _quantity: uint256, _pubkeys: bytes, _signatures: bytes,
                       tx_params) -> None: ...

    def assignNextSigningKeys(self, _numKeys: uint256, tx_params) -> Tuple[bytes, bytes]: ...

    def setNodeOperatorName(self, _id: uint256, _name: string, tx_params) -> None: ...

    def setNodeOperatorActive(self, _id: uint256, _active: bool, tx_params) -> None: ...

    def removeSigningKey(self, _operator_id: uint256, _index: uint256, tx_params) -> None: ...

    def addSigningKeysOperatorBH(self, _operator_id: uint256, _quantity: uint256, _pubkeys: bytes, _signatures: bytes,
                                 tx_params) -> None: ...

    def setNodeOperatorRewardAddress(self, _id: uint256, _rewardAddress: address, tx_params) -> None: ...

    def transferToVault(self, _token: address, tx_params) -> None: ...

    def setNodeOperatorStakingLimit(self, _id: uint256, _stakingLimit: uint64, tx_params) -> None: ...

    def reportStoppedValidators(self, _id: uint256, _stoppedIncrement: uint64, tx_params) -> None: ...

    def initialize(self, _lido: address, tx_params) -> None: ...

    def removeSigningKeyOperatorBH(self, _operator_id: uint256, _index: uint256, tx_params) -> None: ...

    def trimUnusedKeys(self, tx_params) -> None: ...

    hasInitialized: ContractCall
    getEVMScriptExecutor: ContractCall
    getRecoveryVault: ContractCall
    SIGNATURE_LENGTH: ContractCall
    SET_NODE_OPERATOR_ADDRESS_ROLE: ContractCall
    getRewardsDistribution: ContractCall
    SET_NODE_OPERATOR_NAME_ROLE: ContractCall
    ADD_NODE_OPERATOR_ROLE: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getActiveNodeOperatorsCount: ContractCall
    getInitializationBlock: ContractCall
    getUnusedSigningKeyCount: ContractCall
    getNodeOperator: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    PUBKEY_LENGTH: ContractCall
    getNodeOperatorsCount: ContractCall
    getSigningKey: ContractCall
    REPORT_STOPPED_VALIDATORS_ROLE: ContractCall
    kernel: ContractCall
    SET_NODE_OPERATOR_ACTIVE_ROLE: ContractCall
    SET_NODE_OPERATOR_LIMIT_ROLE: ContractCall
    getTotalSigningKeyCount: ContractCall
    isPetrified: ContractCall
    MANAGE_SIGNING_KEYS: ContractCall
    addNodeOperator: ContractTx
    addSigningKeys: ContractTx
    assignNextSigningKeys: ContractTx
    setNodeOperatorName: ContractTx
    setNodeOperatorActive: ContractTx
    removeSigningKey: ContractTx
    addSigningKeysOperatorBH: ContractTx
    setNodeOperatorRewardAddress: ContractTx
    transferToVault: ContractTx
    setNodeOperatorStakingLimit: ContractTx
    reportStoppedValidators: ContractTx
    initialize: ContractTx
    removeSigningKeyOperatorBH: ContractTx
    trimUnusedKeys: ContractTx


class TokenManager(Contract):
    def hasInitialized(self, tx_params) -> bool: ...

    def MAX_VESTINGS_PER_ADDRESS(self, tx_params) -> uint256: ...

    def spendableBalanceOf(self, _holder: address, tx_params) -> uint256: ...

    def getEVMScriptExecutor(self, _script: bytes, tx_params) -> address: ...

    def getRecoveryVault(self, tx_params) -> address: ...

    def getVesting(self, _recipient: address, _vestingId: uint256, tx_params) -> Tuple[
        uint256, uint64, uint64, uint64, bool]: ...

    def transferableBalance(self, _holder: address, _time: uint256, tx_params) -> uint256: ...

    def allowRecoverability(self, _token: address, tx_params) -> bool: ...

    def appId(self, tx_params) -> bytes32: ...

    def ISSUE_ROLE(self, tx_params) -> bytes32: ...

    def getInitializationBlock(self, tx_params) -> uint256: ...

    def vestingsLengths(self, _arg0: address, tx_params) -> uint256: ...

    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], tx_params) -> bool: ...

    def getEVMScriptRegistry(self, tx_params) -> address: ...

    def ASSIGN_ROLE(self, tx_params) -> bytes32: ...

    def BURN_ROLE(self, tx_params) -> bytes32: ...

    def canForward(self, _sender: address, _arg1: bytes, tx_params) -> bool: ...

    def kernel(self, tx_params) -> address: ...

    def isPetrified(self, tx_params) -> bool: ...

    def MINT_ROLE(self, tx_params) -> bytes32: ...

    def maxAccountTokens(self, tx_params) -> uint256: ...

    def REVOKE_VESTINGS_ROLE(self, tx_params) -> bytes32: ...

    def token(self, tx_params) -> address: ...

    def isForwarder(self, tx_params) -> bool: ...

    def assignVested(self, _receiver: address, _amount: uint256, _start: uint64, _cliff: uint64, _vested: uint64,
                     _revokable: bool, tx_params) -> uint256: ...

    def mint(self, _receiver: address, _amount: uint256, tx_params) -> None: ...

    def onTransfer(self, _from: address, _to: address, _amount: uint256, tx_params) -> bool: ...

    def transferToVault(self, _token: address, tx_params) -> None: ...

    def burn(self, _holder: address, _amount: uint256, tx_params) -> None: ...

    def assign(self, _receiver: address, _amount: uint256, tx_params) -> None: ...

    def issue(self, _amount: uint256, tx_params) -> None: ...

    def forward(self, _evmScript: bytes, tx_params) -> None: ...

    def onApprove(self, _arg0: address, _arg1: address, _arg2: uint256, tx_params) -> bool: ...

    def initialize(self, _token: address, _transferable: bool, _maxAccountTokens: uint256, tx_params) -> None: ...

    def proxyPayment(self, _arg0: address, tx_params) -> bool: ...

    def revokeVesting(self, _holder: address, _vestingId: uint256, tx_params) -> None: ...

    hasInitialized: ContractCall
    MAX_VESTINGS_PER_ADDRESS: ContractCall
    spendableBalanceOf: ContractCall
    getEVMScriptExecutor: ContractCall
    getRecoveryVault: ContractCall
    getVesting: ContractCall
    transferableBalance: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    ISSUE_ROLE: ContractCall
    getInitializationBlock: ContractCall
    vestingsLengths: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    ASSIGN_ROLE: ContractCall
    BURN_ROLE: ContractCall
    canForward: ContractCall
    kernel: ContractCall
    isPetrified: ContractCall
    MINT_ROLE: ContractCall
    maxAccountTokens: ContractCall
    REVOKE_VESTINGS_ROLE: ContractCall
    token: ContractCall
    isForwarder: ContractCall
    assignVested: ContractTx
    mint: ContractTx
    onTransfer: ContractTx
    transferToVault: ContractTx
    burn: ContractTx
    assign: ContractTx
    issue: ContractTx
    forward: ContractTx
    onApprove: ContractTx
    initialize: ContractTx
    proxyPayment: ContractTx
    revokeVesting: ContractTx


class Voting(Contract):
    def hasInitialized(self, tx_params) -> bool: ...

    def getEVMScriptExecutor(self, _script: bytes, tx_params) -> address: ...

    def getRecoveryVault(self, tx_params) -> address: ...

    def MODIFY_QUORUM_ROLE(self, tx_params) -> bytes32: ...

    def getVoterState(self, _voteId: uint256, _voter: address, tx_params) -> uint8: ...

    def getVote(self, _voteId: uint256, tx_params) -> Tuple[
        bool, bool, uint64, uint64, uint64, uint64, uint256, uint256, uint256, bytes]: ...

    def MODIFY_SUPPORT_ROLE(self, tx_params) -> bytes32: ...

    def allowRecoverability(self, token: address, tx_params) -> bool: ...

    def appId(self, tx_params) -> bytes32: ...

    def getInitializationBlock(self, tx_params) -> uint256: ...

    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], tx_params) -> bool: ...

    def getEVMScriptRegistry(self, tx_params) -> address: ...

    def voteTime(self, tx_params) -> uint64: ...

    def CREATE_VOTES_ROLE(self, tx_params) -> bytes32: ...

    def canForward(self, _sender: address, _arg1: bytes, tx_params) -> bool: ...

    def canExecute(self, _voteId: uint256, tx_params) -> bool: ...

    def canVote(self, _voteId: uint256, _voter: address, tx_params) -> bool: ...

    def kernel(self, tx_params) -> address: ...

    def minAcceptQuorumPct(self, tx_params) -> uint64: ...

    def isPetrified(self, tx_params) -> bool: ...

    def votesLength(self, tx_params) -> uint256: ...

    def supportRequiredPct(self, tx_params) -> uint64: ...

    def token(self, tx_params) -> address: ...

    def PCT_BASE(self, tx_params) -> uint64: ...

    def isForwarder(self, tx_params) -> bool: ...

    def changeMinAcceptQuorumPct(self, _minAcceptQuorumPct: uint64, tx_params) -> None: ...

    def changeSupportRequiredPct(self, _supportRequiredPct: uint64, tx_params) -> None: ...

    def transferToVault(self, _token: address, tx_params) -> None: ...

    def newVote(self, _executionScript: bytes, _metadata: string, tx_params) -> uint256: ...

    def forward(self, _evmScript: bytes, tx_params) -> None: ...

    def vote(self, _voteId: uint256, _supports: bool, _executesIfDecided: bool, tx_params) -> None: ...

    def initialize(self, _token: address, _supportRequiredPct: uint64, _minAcceptQuorumPct: uint64, _voteTime: uint64,
                   tx_params) -> None: ...

    def newVote(self, _executionScript: bytes, _metadata: string, _castVote: bool, _executesIfDecided: bool,
                tx_params) -> uint256: ...

    def executeVote(self, _voteId: uint256, tx_params) -> None: ...

    hasInitialized: ContractCall
    getEVMScriptExecutor: ContractCall
    getRecoveryVault: ContractCall
    MODIFY_QUORUM_ROLE: ContractCall
    getVoterState: ContractCall
    getVote: ContractCall
    MODIFY_SUPPORT_ROLE: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getInitializationBlock: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    voteTime: ContractCall
    CREATE_VOTES_ROLE: ContractCall
    canForward: ContractCall
    canExecute: ContractCall
    canVote: ContractCall
    kernel: ContractCall
    minAcceptQuorumPct: ContractCall
    isPetrified: ContractCall
    votesLength: ContractCall
    supportRequiredPct: ContractCall
    token: ContractCall
    PCT_BASE: ContractCall
    isForwarder: ContractCall
    changeMinAcceptQuorumPct: ContractTx
    changeSupportRequiredPct: ContractTx
    transferToVault: ContractTx
    newVote: ContractTx
    forward: ContractTx
    vote: ContractTx
    initialize: ContractTx
    newVote: ContractTx
    executeVote: ContractTx


class WithdrawalContractProxy(Contract):
    def implementation(self, tx_params) -> address: ...

    def proxy_getAdmin(self, tx_params) -> address: ...

    def proxy_getIsOssified(self, tx_params) -> bool: ...

    def proxy_changeAdmin(self, newAdmin: address, tx_params) -> None: ...

    def proxy_upgradeTo(self, newImplementation: address, setupCalldata: bytes, tx_params) -> None: ...

    implementation: ContractCall
    proxy_getAdmin: ContractCall
    proxy_getIsOssified: ContractCall
    proxy_changeAdmin: ContractTx
    proxy_upgradeTo: ContractTx
