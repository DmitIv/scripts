from typing import Optional, NewType, Any, Tuple, List
from brownie.typing import AccountsType
from brownie.network.contract import InterfaceContainer, Contract
from brownie.network.contract import ContractTx, ContractCall
from brownie.typing import TransactionReceiptType, AccountsType

uint8 = NewType('uint8', int)
uint16 = NewType('uint16', int)
uint32 = NewType('uint32', int)
uint64 = NewType('uint64', int)
uint128 = NewType('uint128', int)
uint240 = NewType('uint240', int)
uint256 = NewType('uint256', int)
address = NewType('address', str)
bytes32 = NewType('bytes32', str)
string = NewType('string', str)
struct = NewType('struct', Any)



class ACL(Contract):
    def hasInitialized(self, ) -> bool: ...
    def getPermissionParamsLength(self, _entity: address, _app: address, _role: bytes32, ) -> uint256: ...
    def evalParams(self, _paramsHash: bytes32, _who: address, _where: address, _what: bytes32, _how: List[uint256], ) -> bool: ...
    def NO_PERMISSION(self, ) -> bytes32: ...
    def getEVMScriptExecutor(self, _script: bytes, ) -> address: ...
    def getRecoveryVault(self, ) -> address: ...
    def CREATE_PERMISSIONS_ROLE(self, ) -> bytes32: ...
    def hasPermission(self, _who: address, _where: address, _what: bytes32, ) -> bool: ...
    def allowRecoverability(self, token: address, ) -> bool: ...
    def appId(self, ) -> bytes32: ...
    def getInitializationBlock(self, ) -> uint256: ...
    def getPermissionParam(self, _entity: address, _app: address, _role: bytes32, _index: uint256, ) -> Tuple[uint8, uint8, uint240]: ...
    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], ) -> bool: ...
    def getEVMScriptRegistry(self, ) -> address: ...
    def ANY_ENTITY(self, ) -> address: ...
    def getPermissionManager(self, _app: address, _role: bytes32, ) -> address: ...
    def EMPTY_PARAM_HASH(self, ) -> bytes32: ...
    def kernel(self, ) -> address: ...
    def isPetrified(self, ) -> bool: ...
    def BURN_ENTITY(self, ) -> address: ...
    def hasPermission(self, _who: address, _where: address, _what: bytes32, _how: List[uint256], ) -> bool: ...
    def hasPermission(self, _who: address, _where: address, _what: bytes32, _how: bytes, ) -> bool: ...
    def createBurnedPermission(self, _app: address, _role: bytes32, ) -> None: ...
    def burnPermissionManager(self, _app: address, _role: bytes32, ) -> None: ...
    def grantPermission(self, _entity: address, _app: address, _role: bytes32, ) -> None: ...
    def grantPermissionP(self, _entity: address, _app: address, _role: bytes32, _params: List[uint256], ) -> None: ...
    def revokePermission(self, _entity: address, _app: address, _role: bytes32, ) -> None: ...
    def transferToVault(self, _token: address, ) -> None: ...
    def removePermissionManager(self, _app: address, _role: bytes32, ) -> None: ...
    def setPermissionManager(self, _newManager: address, _app: address, _role: bytes32, ) -> None: ...
    def createPermission(self, _entity: address, _app: address, _role: bytes32, _manager: address, ) -> None: ...
    def initialize(self, _permissionsCreator: address, ) -> None: ...

    hasInitialized: ContractCall
    getPermissionParamsLength: ContractCall
    evalParams: ContractCall
    NO_PERMISSION: ContractCall
    getEVMScriptExecutor: ContractCall
    getRecoveryVault: ContractCall
    CREATE_PERMISSIONS_ROLE: ContractCall
    hasPermission: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getInitializationBlock: ContractCall
    getPermissionParam: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    ANY_ENTITY: ContractCall
    getPermissionManager: ContractCall
    EMPTY_PARAM_HASH: ContractCall
    kernel: ContractCall
    isPetrified: ContractCall
    BURN_ENTITY: ContractCall
    hasPermission: ContractCall
    hasPermission: ContractCall
    createBurnedPermission: ContractTx
    burnPermissionManager: ContractTx
    grantPermission: ContractTx
    grantPermissionP: ContractTx
    revokePermission: ContractTx
    transferToVault: ContractTx
    removePermissionManager: ContractTx
    setPermissionManager: ContractTx
    createPermission: ContractTx
    initialize: ContractTx


class CurveRewardsManager(Contract):
    def is_rewards_period_finished(self, ) -> bool: ...
    def owner(self, ) -> address: ...
    def rewards_contract(self, ) -> address: ...
    def transfer_ownership(self, _to: address, ) -> None: ...
    def set_rewards_contract(self, _rewards_contract: address, ) -> None: ...
    def start_next_rewards_period(self, ) -> None: ...
    def recover_erc20(self, _token: address, ) -> None: ...
    def recover_erc20(self, _token: address, _recipient: address, ) -> None: ...

    is_rewards_period_finished: ContractCall
    owner: ContractCall
    rewards_contract: ContractCall
    transfer_ownership: ContractTx
    set_rewards_contract: ContractTx
    start_next_rewards_period: ContractTx
    recover_erc20: ContractTx
    recover_erc20: ContractTx


class ERC20(Contract):
    def allowance(self, _owner: address, _spender: address, ) -> uint256: ...
    def balanceOf(self, _owner: address, ) -> uint256: ...
    def decimals(self, ) -> uint256: ...
    def name(self, ) -> string: ...
    def symbol(self, ) -> string: ...
    def totalSupply(self, ) -> uint256: ...
    def approve(self, _spender: address, _value: uint256, ) -> bool: ...
    def transfer(self, _to: address, _value: uint256, ) -> bool: ...
    def transferFrom(self, _from: address, _to: address, _value: uint256, ) -> bool: ...

    allowance: ContractCall
    balanceOf: ContractCall
    decimals: ContractCall
    name: ContractCall
    symbol: ContractCall
    totalSupply: ContractCall
    approve: ContractTx
    transfer: ContractTx
    transferFrom: ContractTx


class Finance(Contract):
    def hasInitialized(self, ) -> bool: ...
    def CREATE_PAYMENTS_ROLE(self, ) -> bytes32: ...
    def getBudget(self, _token: address, ) -> Tuple[uint256, bool]: ...
    def getEVMScriptExecutor(self, _script: bytes, ) -> address: ...
    def getPayment(self, _paymentId: uint256, ) -> Tuple[address, address, uint256, uint64, uint64, uint64, bool, uint64, address]: ...
    def getRecoveryVault(self, ) -> address: ...
    def getTransaction(self, _transactionId: uint256, ) -> Tuple[uint64, uint256, uint256, uint64, address, address, bool, uint64]: ...
    def CHANGE_PERIOD_ROLE(self, ) -> bytes32: ...
    def CHANGE_BUDGETS_ROLE(self, ) -> bytes32: ...
    def getPeriod(self, _periodId: uint64, ) -> Tuple[bool, uint64, uint64, uint256, uint256]: ...
    def periodsLength(self, ) -> uint64: ...
    def allowRecoverability(self, _arg0: address, ) -> bool: ...
    def appId(self, ) -> bytes32: ...
    def getInitializationBlock(self, ) -> uint256: ...
    def EXECUTE_PAYMENTS_ROLE(self, ) -> bytes32: ...
    def currentPeriodId(self, ) -> uint64: ...
    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], ) -> bool: ...
    def getEVMScriptRegistry(self, ) -> address: ...
    def getPeriodDuration(self, ) -> uint64: ...
    def nextPaymentTime(self, _paymentId: uint256, ) -> uint64: ...
    def getPeriodTokenStatement(self, _periodId: uint64, _token: address, ) -> Tuple[uint256, uint256]: ...
    def kernel(self, ) -> address: ...
    def paymentsNextIndex(self, ) -> uint256: ...
    def isPetrified(self, ) -> bool: ...
    def canMakePayment(self, _token: address, _amount: uint256, ) -> bool: ...
    def MANAGE_PAYMENTS_ROLE(self, ) -> bytes32: ...
    def transactionsNextIndex(self, ) -> uint256: ...
    def getRemainingBudget(self, _token: address, ) -> uint256: ...
    def vault(self, ) -> address: ...
    def newScheduledPayment(self, _token: address, _receiver: address, _amount: uint256, _initialPaymentTime: uint64, _interval: uint64, _maxExecutions: uint64, _reference: string, ) -> uint256: ...
    def executePayment(self, _paymentId: uint256, ) -> None: ...
    def initialize(self, _vault: address, _periodDuration: uint64, ) -> None: ...
    def removeBudget(self, _token: address, ) -> None: ...
    def setPaymentStatus(self, _paymentId: uint256, _active: bool, ) -> None: ...
    def receiverExecutePayment(self, _paymentId: uint256, ) -> None: ...
    def setPeriodDuration(self, _periodDuration: uint64, ) -> None: ...
    def setBudget(self, _token: address, _amount: uint256, ) -> None: ...
    def recoverToVault(self, _token: address, ) -> None: ...
    def transferToVault(self, _token: address, ) -> None: ...
    def tryTransitionAccountingPeriod(self, _maxTransitions: uint64, ) -> bool: ...
    def deposit(self, _token: address, _amount: uint256, _reference: string, ) -> None: ...
    def newImmediatePayment(self, _token: address, _receiver: address, _amount: uint256, _reference: string, ) -> None: ...

    hasInitialized: ContractCall
    CREATE_PAYMENTS_ROLE: ContractCall
    getBudget: ContractCall
    getEVMScriptExecutor: ContractCall
    getPayment: ContractCall
    getRecoveryVault: ContractCall
    getTransaction: ContractCall
    CHANGE_PERIOD_ROLE: ContractCall
    CHANGE_BUDGETS_ROLE: ContractCall
    getPeriod: ContractCall
    periodsLength: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getInitializationBlock: ContractCall
    EXECUTE_PAYMENTS_ROLE: ContractCall
    currentPeriodId: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    getPeriodDuration: ContractCall
    nextPaymentTime: ContractCall
    getPeriodTokenStatement: ContractCall
    kernel: ContractCall
    paymentsNextIndex: ContractCall
    isPetrified: ContractCall
    canMakePayment: ContractCall
    MANAGE_PAYMENTS_ROLE: ContractCall
    transactionsNextIndex: ContractCall
    getRemainingBudget: ContractCall
    vault: ContractCall
    newScheduledPayment: ContractTx
    executePayment: ContractTx
    initialize: ContractTx
    removeBudget: ContractTx
    setPaymentStatus: ContractTx
    receiverExecutePayment: ContractTx
    setPeriodDuration: ContractTx
    setBudget: ContractTx
    recoverToVault: ContractTx
    transferToVault: ContractTx
    tryTransitionAccountingPeriod: ContractTx
    deposit: ContractTx
    newImmediatePayment: ContractTx


class Lido(Contract):
    def name(self, ) -> string: ...
    def hasInitialized(self, ) -> bool: ...
    def getInsuranceFund(self, ) -> address: ...
    def totalSupply(self, ) -> uint256: ...
    def getSharesByPooledEth(self, _ethAmount: uint256, ) -> uint256: ...
    def getOperators(self, ) -> address: ...
    def getEVMScriptExecutor(self, _script: bytes, ) -> address: ...
    def decimals(self, ) -> uint8: ...
    def getRecoveryVault(self, ) -> address: ...
    def DEPOSIT_SIZE(self, ) -> uint256: ...
    def getTotalPooledEther(self, ) -> uint256: ...
    def PAUSE_ROLE(self, ) -> bytes32: ...
    def getTreasury(self, ) -> address: ...
    def SET_ORACLE(self, ) -> bytes32: ...
    def isStopped(self, ) -> bool: ...
    def MANAGE_WITHDRAWAL_KEY(self, ) -> bytes32: ...
    def getBufferedEther(self, ) -> uint256: ...
    def SIGNATURE_LENGTH(self, ) -> uint256: ...
    def getWithdrawalCredentials(self, ) -> bytes32: ...
    def balanceOf(self, _account: address, ) -> uint256: ...
    def getFeeDistribution(self, ) -> Tuple[uint16, uint16, uint16]: ...
    def getPooledEthByShares(self, _sharesAmount: uint256, ) -> uint256: ...
    def allowRecoverability(self, token: address, ) -> bool: ...
    def appId(self, ) -> bytes32: ...
    def getOracle(self, ) -> address: ...
    def getInitializationBlock(self, ) -> uint256: ...
    def symbol(self, ) -> string: ...
    def MANAGE_FEE(self, ) -> bytes32: ...
    def SET_TREASURY(self, ) -> bytes32: ...
    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], ) -> bool: ...
    def WITHDRAWAL_CREDENTIALS_LENGTH(self, ) -> uint256: ...
    def getEVMScriptRegistry(self, ) -> address: ...
    def PUBKEY_LENGTH(self, ) -> uint256: ...
    def getDepositContract(self, ) -> address: ...
    def getBeaconStat(self, ) -> Tuple[uint256, uint256, uint256]: ...
    def BURN_ROLE(self, ) -> bytes32: ...
    def getFee(self, ) -> uint16: ...
    def SET_INSURANCE_FUND(self, ) -> bytes32: ...
    def kernel(self, ) -> address: ...
    def getTotalShares(self, ) -> uint256: ...
    def allowance(self, _owner: address, _spender: address, ) -> uint256: ...
    def isPetrified(self, ) -> bool: ...
    def sharesOf(self, _account: address, ) -> uint256: ...
    def resume(self, ) -> None: ...
    def stop(self, ) -> None: ...
    def approve(self, _spender: address, _amount: uint256, ) -> bool: ...
    def initialize(self, depositContract: address, _oracle: address, _operators: address, _treasury: address, _insuranceFund: address, ) -> None: ...
    def transferFrom(self, _sender: address, _recipient: address, _amount: uint256, ) -> bool: ...
    def increaseAllowance(self, _spender: address, _addedValue: uint256, ) -> bool: ...
    def setOracle(self, _oracle: address, ) -> None: ...
    def setFeeDistribution(self, _treasuryFeeBasisPoints: uint16, _insuranceFeeBasisPoints: uint16, _operatorsFeeBasisPoints: uint16, ) -> None: ...
    def setFee(self, _feeBasisPoints: uint16, ) -> None: ...
    def depositBufferedEther(self, _maxDeposits: uint256, ) -> None: ...
    def transferToVault(self, _token: address, ) -> None: ...
    def submit(self, _referral: address, ) -> uint256: ...
    def decreaseAllowance(self, _spender: address, _subtractedValue: uint256, ) -> bool: ...
    def withdraw(self, _amount: uint256, _pubkeyHash: bytes32, ) -> None: ...
    def transfer(self, _recipient: address, _amount: uint256, ) -> bool: ...
    def setInsuranceFund(self, _insuranceFund: address, ) -> None: ...
    def setWithdrawalCredentials(self, _withdrawalCredentials: bytes32, ) -> None: ...
    def depositBufferedEther(self, ) -> None: ...
    def burnShares(self, _account: address, _sharesAmount: uint256, ) -> uint256: ...
    def setTreasury(self, _treasury: address, ) -> None: ...
    def pushBeacon(self, _beaconValidators: uint256, _beaconBalance: uint256, ) -> None: ...

    name: ContractCall
    hasInitialized: ContractCall
    getInsuranceFund: ContractCall
    totalSupply: ContractCall
    getSharesByPooledEth: ContractCall
    getOperators: ContractCall
    getEVMScriptExecutor: ContractCall
    decimals: ContractCall
    getRecoveryVault: ContractCall
    DEPOSIT_SIZE: ContractCall
    getTotalPooledEther: ContractCall
    PAUSE_ROLE: ContractCall
    getTreasury: ContractCall
    SET_ORACLE: ContractCall
    isStopped: ContractCall
    MANAGE_WITHDRAWAL_KEY: ContractCall
    getBufferedEther: ContractCall
    SIGNATURE_LENGTH: ContractCall
    getWithdrawalCredentials: ContractCall
    balanceOf: ContractCall
    getFeeDistribution: ContractCall
    getPooledEthByShares: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getOracle: ContractCall
    getInitializationBlock: ContractCall
    symbol: ContractCall
    MANAGE_FEE: ContractCall
    SET_TREASURY: ContractCall
    canPerform: ContractCall
    WITHDRAWAL_CREDENTIALS_LENGTH: ContractCall
    getEVMScriptRegistry: ContractCall
    PUBKEY_LENGTH: ContractCall
    getDepositContract: ContractCall
    getBeaconStat: ContractCall
    BURN_ROLE: ContractCall
    getFee: ContractCall
    SET_INSURANCE_FUND: ContractCall
    kernel: ContractCall
    getTotalShares: ContractCall
    allowance: ContractCall
    isPetrified: ContractCall
    sharesOf: ContractCall
    resume: ContractTx
    stop: ContractTx
    approve: ContractTx
    initialize: ContractTx
    transferFrom: ContractTx
    increaseAllowance: ContractTx
    setOracle: ContractTx
    setFeeDistribution: ContractTx
    setFee: ContractTx
    depositBufferedEther: ContractTx
    transferToVault: ContractTx
    submit: ContractTx
    decreaseAllowance: ContractTx
    withdraw: ContractTx
    transfer: ContractTx
    setInsuranceFund: ContractTx
    setWithdrawalCredentials: ContractTx
    depositBufferedEther: ContractTx
    burnShares: ContractTx
    setTreasury: ContractTx
    pushBeacon: ContractTx


class Multicall2(Contract):
    def aggregate(self, calls: List[struct], ) -> Tuple[uint256, List[bytes]]: ...
    def blockAndAggregate(self, calls: List[struct], ) -> Tuple[uint256, bytes32, List[struct]]: ...
    def getBlockHash(self, blockNumber: uint256, ) -> bytes32: ...
    def getBlockNumber(self, ) -> uint256: ...
    def getCurrentBlockCoinbase(self, ) -> address: ...
    def getCurrentBlockDifficulty(self, ) -> uint256: ...
    def getCurrentBlockGasLimit(self, ) -> uint256: ...
    def getCurrentBlockTimestamp(self, ) -> uint256: ...
    def getEthBalance(self, addr: address, ) -> uint256: ...
    def getLastBlockHash(self, ) -> bytes32: ...
    def tryAggregate(self, requireSuccess: bool, calls: List[struct], ) -> List[struct]: ...
    def tryBlockAndAggregate(self, requireSuccess: bool, calls: List[struct], ) -> Tuple[uint256, bytes32, List[struct]]: ...

    aggregate: ContractCall
    blockAndAggregate: ContractCall
    getBlockHash: ContractCall
    getBlockNumber: ContractCall
    getCurrentBlockCoinbase: ContractCall
    getCurrentBlockDifficulty: ContractCall
    getCurrentBlockGasLimit: ContractCall
    getCurrentBlockTimestamp: ContractCall
    getEthBalance: ContractCall
    getLastBlockHash: ContractCall
    tryAggregate: ContractCall
    tryBlockAndAggregate: ContractCall


class NodeOperatorsRegistry(Contract):
    def hasInitialized(self, ) -> bool: ...
    def getEVMScriptExecutor(self, _script: bytes, ) -> address: ...
    def getRecoveryVault(self, ) -> address: ...
    def SIGNATURE_LENGTH(self, ) -> uint256: ...
    def SET_NODE_OPERATOR_ADDRESS_ROLE(self, ) -> bytes32: ...
    def getRewardsDistribution(self, _totalRewardShares: uint256, ) -> Tuple[List[address], List[uint256]]: ...
    def SET_NODE_OPERATOR_NAME_ROLE(self, ) -> bytes32: ...
    def ADD_NODE_OPERATOR_ROLE(self, ) -> bytes32: ...
    def allowRecoverability(self, token: address, ) -> bool: ...
    def appId(self, ) -> bytes32: ...
    def getActiveNodeOperatorsCount(self, ) -> uint256: ...
    def getInitializationBlock(self, ) -> uint256: ...
    def getUnusedSigningKeyCount(self, _operator_id: uint256, ) -> uint256: ...
    def getNodeOperator(self, _id: uint256, _fullInfo: bool, ) -> Tuple[bool, string, address, uint64, uint64, uint64, uint64]: ...
    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], ) -> bool: ...
    def getEVMScriptRegistry(self, ) -> address: ...
    def PUBKEY_LENGTH(self, ) -> uint256: ...
    def getNodeOperatorsCount(self, ) -> uint256: ...
    def getSigningKey(self, _operator_id: uint256, _index: uint256, ) -> Tuple[bytes, bytes, bool]: ...
    def REPORT_STOPPED_VALIDATORS_ROLE(self, ) -> bytes32: ...
    def kernel(self, ) -> address: ...
    def SET_NODE_OPERATOR_ACTIVE_ROLE(self, ) -> bytes32: ...
    def SET_NODE_OPERATOR_LIMIT_ROLE(self, ) -> bytes32: ...
    def getTotalSigningKeyCount(self, _operator_id: uint256, ) -> uint256: ...
    def isPetrified(self, ) -> bool: ...
    def MANAGE_SIGNING_KEYS(self, ) -> bytes32: ...
    def addNodeOperator(self, _name: string, _rewardAddress: address, _stakingLimit: uint64, ) -> uint256: ...
    def addSigningKeys(self, _operator_id: uint256, _quantity: uint256, _pubkeys: bytes, _signatures: bytes, ) -> None: ...
    def assignNextSigningKeys(self, _numKeys: uint256, ) -> Tuple[bytes, bytes]: ...
    def setNodeOperatorName(self, _id: uint256, _name: string, ) -> None: ...
    def setNodeOperatorActive(self, _id: uint256, _active: bool, ) -> None: ...
    def removeSigningKey(self, _operator_id: uint256, _index: uint256, ) -> None: ...
    def addSigningKeysOperatorBH(self, _operator_id: uint256, _quantity: uint256, _pubkeys: bytes, _signatures: bytes, ) -> None: ...
    def setNodeOperatorRewardAddress(self, _id: uint256, _rewardAddress: address, ) -> None: ...
    def transferToVault(self, _token: address, ) -> None: ...
    def setNodeOperatorStakingLimit(self, _id: uint256, _stakingLimit: uint64, ) -> None: ...
    def reportStoppedValidators(self, _id: uint256, _stoppedIncrement: uint64, ) -> None: ...
    def initialize(self, _lido: address, ) -> None: ...
    def removeSigningKeyOperatorBH(self, _operator_id: uint256, _index: uint256, ) -> None: ...
    def trimUnusedKeys(self, ) -> None: ...

    hasInitialized: ContractCall
    getEVMScriptExecutor: ContractCall
    getRecoveryVault: ContractCall
    SIGNATURE_LENGTH: ContractCall
    SET_NODE_OPERATOR_ADDRESS_ROLE: ContractCall
    getRewardsDistribution: ContractCall
    SET_NODE_OPERATOR_NAME_ROLE: ContractCall
    ADD_NODE_OPERATOR_ROLE: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getActiveNodeOperatorsCount: ContractCall
    getInitializationBlock: ContractCall
    getUnusedSigningKeyCount: ContractCall
    getNodeOperator: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    PUBKEY_LENGTH: ContractCall
    getNodeOperatorsCount: ContractCall
    getSigningKey: ContractCall
    REPORT_STOPPED_VALIDATORS_ROLE: ContractCall
    kernel: ContractCall
    SET_NODE_OPERATOR_ACTIVE_ROLE: ContractCall
    SET_NODE_OPERATOR_LIMIT_ROLE: ContractCall
    getTotalSigningKeyCount: ContractCall
    isPetrified: ContractCall
    MANAGE_SIGNING_KEYS: ContractCall
    addNodeOperator: ContractTx
    addSigningKeys: ContractTx
    assignNextSigningKeys: ContractTx
    setNodeOperatorName: ContractTx
    setNodeOperatorActive: ContractTx
    removeSigningKey: ContractTx
    addSigningKeysOperatorBH: ContractTx
    setNodeOperatorRewardAddress: ContractTx
    transferToVault: ContractTx
    setNodeOperatorStakingLimit: ContractTx
    reportStoppedValidators: ContractTx
    initialize: ContractTx
    removeSigningKeyOperatorBH: ContractTx
    trimUnusedKeys: ContractTx


class TokenManager(Contract):
    def hasInitialized(self, ) -> bool: ...
    def MAX_VESTINGS_PER_ADDRESS(self, ) -> uint256: ...
    def spendableBalanceOf(self, _holder: address, ) -> uint256: ...
    def getEVMScriptExecutor(self, _script: bytes, ) -> address: ...
    def getRecoveryVault(self, ) -> address: ...
    def getVesting(self, _recipient: address, _vestingId: uint256, ) -> Tuple[uint256, uint64, uint64, uint64, bool]: ...
    def transferableBalance(self, _holder: address, _time: uint256, ) -> uint256: ...
    def allowRecoverability(self, _token: address, ) -> bool: ...
    def appId(self, ) -> bytes32: ...
    def ISSUE_ROLE(self, ) -> bytes32: ...
    def getInitializationBlock(self, ) -> uint256: ...
    def vestingsLengths(self, _arg0: address, ) -> uint256: ...
    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], ) -> bool: ...
    def getEVMScriptRegistry(self, ) -> address: ...
    def ASSIGN_ROLE(self, ) -> bytes32: ...
    def BURN_ROLE(self, ) -> bytes32: ...
    def canForward(self, _sender: address, _arg1: bytes, ) -> bool: ...
    def kernel(self, ) -> address: ...
    def isPetrified(self, ) -> bool: ...
    def MINT_ROLE(self, ) -> bytes32: ...
    def maxAccountTokens(self, ) -> uint256: ...
    def REVOKE_VESTINGS_ROLE(self, ) -> bytes32: ...
    def token(self, ) -> address: ...
    def isForwarder(self, ) -> bool: ...
    def assignVested(self, _receiver: address, _amount: uint256, _start: uint64, _cliff: uint64, _vested: uint64, _revokable: bool, ) -> uint256: ...
    def mint(self, _receiver: address, _amount: uint256, ) -> None: ...
    def onTransfer(self, _from: address, _to: address, _amount: uint256, ) -> bool: ...
    def transferToVault(self, _token: address, ) -> None: ...
    def burn(self, _holder: address, _amount: uint256, ) -> None: ...
    def assign(self, _receiver: address, _amount: uint256, ) -> None: ...
    def issue(self, _amount: uint256, ) -> None: ...
    def forward(self, _evmScript: bytes, ) -> None: ...
    def onApprove(self, _arg0: address, _arg1: address, _arg2: uint256, ) -> bool: ...
    def initialize(self, _token: address, _transferable: bool, _maxAccountTokens: uint256, ) -> None: ...
    def proxyPayment(self, _arg0: address, ) -> bool: ...
    def revokeVesting(self, _holder: address, _vestingId: uint256, ) -> None: ...

    hasInitialized: ContractCall
    MAX_VESTINGS_PER_ADDRESS: ContractCall
    spendableBalanceOf: ContractCall
    getEVMScriptExecutor: ContractCall
    getRecoveryVault: ContractCall
    getVesting: ContractCall
    transferableBalance: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    ISSUE_ROLE: ContractCall
    getInitializationBlock: ContractCall
    vestingsLengths: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    ASSIGN_ROLE: ContractCall
    BURN_ROLE: ContractCall
    canForward: ContractCall
    kernel: ContractCall
    isPetrified: ContractCall
    MINT_ROLE: ContractCall
    maxAccountTokens: ContractCall
    REVOKE_VESTINGS_ROLE: ContractCall
    token: ContractCall
    isForwarder: ContractCall
    assignVested: ContractTx
    mint: ContractTx
    onTransfer: ContractTx
    transferToVault: ContractTx
    burn: ContractTx
    assign: ContractTx
    issue: ContractTx
    forward: ContractTx
    onApprove: ContractTx
    initialize: ContractTx
    proxyPayment: ContractTx
    revokeVesting: ContractTx


class Voting(Contract):
    def hasInitialized(self, ) -> bool: ...
    def getEVMScriptExecutor(self, _script: bytes, ) -> address: ...
    def getRecoveryVault(self, ) -> address: ...
    def MODIFY_QUORUM_ROLE(self, ) -> bytes32: ...
    def getVoterState(self, _voteId: uint256, _voter: address, ) -> uint8: ...
    def getVote(self, _voteId: uint256, ) -> Tuple[bool, bool, uint64, uint64, uint64, uint64, uint256, uint256, uint256, bytes]: ...
    def MODIFY_SUPPORT_ROLE(self, ) -> bytes32: ...
    def allowRecoverability(self, token: address, ) -> bool: ...
    def appId(self, ) -> bytes32: ...
    def getInitializationBlock(self, ) -> uint256: ...
    def canPerform(self, _sender: address, _role: bytes32, _params: List[uint256], ) -> bool: ...
    def getEVMScriptRegistry(self, ) -> address: ...
    def voteTime(self, ) -> uint64: ...
    def CREATE_VOTES_ROLE(self, ) -> bytes32: ...
    def canForward(self, _sender: address, _arg1: bytes, ) -> bool: ...
    def canExecute(self, _voteId: uint256, ) -> bool: ...
    def canVote(self, _voteId: uint256, _voter: address, ) -> bool: ...
    def kernel(self, ) -> address: ...
    def minAcceptQuorumPct(self, ) -> uint64: ...
    def isPetrified(self, ) -> bool: ...
    def votesLength(self, ) -> uint256: ...
    def supportRequiredPct(self, ) -> uint64: ...
    def token(self, ) -> address: ...
    def PCT_BASE(self, ) -> uint64: ...
    def isForwarder(self, ) -> bool: ...
    def changeMinAcceptQuorumPct(self, _minAcceptQuorumPct: uint64, ) -> None: ...
    def changeSupportRequiredPct(self, _supportRequiredPct: uint64, ) -> None: ...
    def transferToVault(self, _token: address, ) -> None: ...
    def newVote(self, _executionScript: bytes, _metadata: string, ) -> uint256: ...
    def forward(self, _evmScript: bytes, ) -> None: ...
    def vote(self, _voteId: uint256, _supports: bool, _executesIfDecided: bool, ) -> None: ...
    def initialize(self, _token: address, _supportRequiredPct: uint64, _minAcceptQuorumPct: uint64, _voteTime: uint64, ) -> None: ...
    def newVote(self, _executionScript: bytes, _metadata: string, _castVote: bool, _executesIfDecided: bool, ) -> uint256: ...
    def executeVote(self, _voteId: uint256, ) -> None: ...

    hasInitialized: ContractCall
    getEVMScriptExecutor: ContractCall
    getRecoveryVault: ContractCall
    MODIFY_QUORUM_ROLE: ContractCall
    getVoterState: ContractCall
    getVote: ContractCall
    MODIFY_SUPPORT_ROLE: ContractCall
    allowRecoverability: ContractCall
    appId: ContractCall
    getInitializationBlock: ContractCall
    canPerform: ContractCall
    getEVMScriptRegistry: ContractCall
    voteTime: ContractCall
    CREATE_VOTES_ROLE: ContractCall
    canForward: ContractCall
    canExecute: ContractCall
    canVote: ContractCall
    kernel: ContractCall
    minAcceptQuorumPct: ContractCall
    isPetrified: ContractCall
    votesLength: ContractCall
    supportRequiredPct: ContractCall
    token: ContractCall
    PCT_BASE: ContractCall
    isForwarder: ContractCall
    changeMinAcceptQuorumPct: ContractTx
    changeSupportRequiredPct: ContractTx
    transferToVault: ContractTx
    newVote: ContractTx
    forward: ContractTx
    vote: ContractTx
    initialize: ContractTx
    newVote: ContractTx
    executeVote: ContractTx


class WithdrawalContractProxy(Contract):
    def implementation(self, ) -> address: ...
    def proxy_getAdmin(self, ) -> address: ...
    def proxy_getIsOssified(self, ) -> bool: ...
    def proxy_changeAdmin(self, newAdmin: address, ) -> None: ...
    def proxy_upgradeTo(self, newImplementation: address, setupCalldata: bytes, ) -> None: ...

    implementation: ContractCall
    proxy_getAdmin: ContractCall
    proxy_getIsOssified: ContractCall
    proxy_changeAdmin: ContractTx
    proxy_upgradeTo: ContractTx



class BrownieInterface(InterfaceContainer):
    def ACL(self, address: str, owner: Optional[AccountsType] = None) -> ACL: ...
    def CurveRewardsManager(self, address: str, owner: Optional[AccountsType] = None) -> CurveRewardsManager: ...
    def ERC20(self, address: str, owner: Optional[AccountsType] = None) -> ERC20: ...
    def Finance(self, address: str, owner: Optional[AccountsType] = None) -> Finance: ...
    def Lido(self, address: str, owner: Optional[AccountsType] = None) -> Lido: ...
    def Multicall2(self, address: str, owner: Optional[AccountsType] = None) -> Multicall2: ...
    def NodeOperatorsRegistry(self, address: str, owner: Optional[AccountsType] = None) -> NodeOperatorsRegistry: ...
    def TokenManager(self, address: str, owner: Optional[AccountsType] = None) -> TokenManager: ...
    def Voting(self, address: str, owner: Optional[AccountsType] = None) -> Voting: ...
    def WithdrawalContractProxy(self, address: str, owner: Optional[AccountsType] = None) -> WithdrawalContractProxy: ...
